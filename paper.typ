#set page(
  paper: "a4",
  margin: (x: 1.5cm, y: 1.5cm),
)

#set par(
  justify: true
)

#show raw: set block(
  above: 1em,
  below: 2em,
)

#let clr-caption = rgb("777777")
#let que = [*(?)*]

#let cred(url) = link(
  url,
  text(
    fill: blue
  )[
    \[cred\]
  ],
)

#let caption(body) = text(fill: clr-caption)[
  #par[
    #body
  ]
]

#align(center, text(18pt)[
  *Материалы по языкам программирования*
])

= Динамическое окружение
#caption[
  Понятие динамического окружения. Порядок формирования и использования динамического окружения.
]

*Динамическое окружение* #sym.dash.em окружение, в котором присутствует структура данных, связывающая имена переменных с их значением во время выполнения очередной инструкции.

Рассмотрим пример формирования динамического окружения на языке SML. В примере упростим представление динамического окружения до массива, содержащего пару "имя переменной" #sym.arrow.l.r "значение". Функции будем связывать с их замыканиями:
```sml
val x = 2 (* [(x, 2)] *)
val y = x + 3 (* [(y, 5), (x, 2)] *)
val z = x + y (* [(z, 7), (y, 5), (x, 2)] *)
(* #[(x, 49), (z, 7), (y, 5), (x, 2)] произошло затенение *)
val x = z * z
(* [(x, 49), (z, 7), (y, 5), (x, 2)] в let создается временное динамическое окружение *)
val z =
  let
    val x = 7 (* [(x, 7), (x, 49), (z, 7), (y, 5), (x, 2)] *)
    val d = 1 (* [(d, 1), (x, 7), (x, 49), (z, 7), (y, 5), (x, 2)] *)
  in
    z + x + d (* [(z, 15), (d, 1), (x, 7), (x, 49), (z, 7), (y, 5), (x, 2)] *)
  end (* [(z, 15), (x, 49), (z, 7), (y, 5), (x, 2)] *)
(* [(e, -10), (z, 15), (x, 49), (z, 7), (y, 5), (x, 2)] *)
val e = z - 25
(* [(x, 3), (e, -10), (z, 15), (x, 49), (z, 7), (y, 5), (x, 2)] *)
val x = 3
(* [(f, [x], x + 25, [(x, 3), ...]), (x, 3), (e, -10), (z, 15), (x, 49), (z, 7), (y, 5), (x, 2)] *)
fun f x = x + 25
```

Функция в динамическое окружение записывается в виде замыкания:
#align(center)[
  ```text [форм. параметры], тело, [копия текущего окружения]```
]

Здесь отражён основной принцип формирования динамического окружения. Он не идеален, и существует множество других более эффективных реализаций.
#cred("https://course.sgu.ru/mod/forum/discuss.php?d=14597#p28625")

= Абстракции
#caption[
  Что понимается под терминами "Абстракция данных", "Абстракция процессов"? Что значит "построение абстракций"? Что такое "Барьеры абстракций"? За счет чего обеспечивается абстрагирование?
]

*Абстрагирование* #sym.dash.em процесс удаления характеристик чего-либо с целью сведения его к набору существенных элементов.

*Абстракция данных* #sym.dash.em сведение набора данных к упрощенному представлению целого.

*Абстракция процессов* фокусируется на сокрытии деталей реализации процесса или алгоритма и предоставлении упрощенного интерфейса для его запуска (*методы*). Это позволяет инкапсулировать набор операций в единую сущность. Причём пользователь объекта не обязан знать реализацию метода.

*Построение абстракций* #sym.dash.em процесс компоновки техник абстракции данных и абстракции процессов для постоения одной абстрактной сущности #sym.dash.em объекта или класса.

#que *Барьеры абстракций* #sym.dash.em те высокоуровневые операции, которые предоставлены пользователю создателями класса. Нарушение барьера абстракций #sym.dash.em использование низкоуровневых методов и полей, когда имеются более высокоуровневые, выполняющие ту же задачу.

В объектно ориентированных языках программирования абстракция реализована через понятия классов и объектов (абстрагирование данных).
Она используется для того, чтобы скрывать низкоуровневые детали компонентов программы, содержащих логику, что позволяет упростить процесс разработки.

В ООП приложения строятся вокруг объектов и *сообщений*, с помощью которых объектам можно подавать сигнал на изменение внутреннего состояния или запрашивать информацию о нём (абстрагирование процессов).

Пример на языке Ruby:
```rb
class Point
  attr_accessor :x, :y

  def initialize(x, y)
    @x = x
    @y = y
  end

  def move(dx, dy)
    @x += dx
    @y += dy
  end
end

# абстракция данных: передаем данные о точке одним объектом
def diag_move(p, v)
  p.move(v, v)
end

p1 = Point.new(x, y)

# абстракция процесса
p1.move(4, 7)

# нарушение барьера абстракций
p1.x += 10
p1.y += 11
```

= Рекурсивный и итерационный процесс
#caption[
  Рекурсивный и итерационный процесс. Хвостовая рекурсия. Преимущества хвостовой рекурсии над нехвостовой. Преимущества нехвостовой рекурсии над хвостовой.
]
*Рекурсия* #sym.dash.em это функция, которая вызывает саму себя, но с другими значениями параметров.

*Рекурсивный процесс* #sym.dash.em это процесс вызова рекурсивной функции, при котором состояние вызывающей функции сохраняется в памяти до момента, пока не будет известен результат вызываемой функции.

*Итерационный процесс* #sym.dash.em процесс вызова рекурсивной функции без сохранения в памяти состояния вызывающей функции.

Функции, где рекурсивный вызов является последней выполняемой операцией называются *функциями с хвостовой рекурсией*.

== Две реализации функции вычисления факториала на языке SML
С хвостовой рекурсией:
```sml
fun fact (n, acc) =
  if (n < 1) then acc
  else fact (n - 1, n * acc)
```

Без хвостовой рекурсии #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14588#p28648"):
```sml
fun fact n =
  if (n < 1) then 1
  else n * fact (n - 1)
```

Одним из основных преимуществ хвостовой рекурсии является меньший расход памяти, а нехвостовой #sym.dash.em наглядность выполнения операций и меньшая громоздкость кода.

== Хвостовая рекурсия в языках с ленивой моделью вычислений
Хвостовая рекурсия может быть неприемлема в языках, где присутствуют ленивые вычисления. Рассмотрим пример на языке Haskell:
```hs
-- без хвостовой рекурсии
fromTo n m = n : xs
  where
    xs = if n >= m then []
         else fromTo (n + 1) m

-- с хвостовой рекурсией
fromTo' n m = fromToTmp [] m
  where
    fromToTmp acc m' =
      if m' < n then acc
      else fromToTmp (m' : acc) (m' - 1)

nth l n =
  if n == 0 then head l
  else nth (tail l) (n - 1)
```

Вызов ```hs nth (fromTo 5 2000000) 5``` завершится за приемлемое время. Но ```hs nth (fromTo' 5 2000000) 5``` нет. Так происходит потому, что в ``` fromTo ``` результат может быть вычислен до СГНФ, и `nth` сможет выполнить операцию почти моментально. А в `fromTo'` сначала должен создаться полный список, и только потом `nth` сможет извлечь из него значение.

= Модели вычислений
#caption[
  Модели вычислений: аппликативные вычисления, нормальный порядок вычислений.
]

*Аппликативные вычисления* #sym.dash.em стратегия вычисления, при которой сначала вычисляются аргументы функции (значения фактических параметров), потом вызывается сама функция. Проблема таких вычислений #sym.dash.em выражения могут быть невычислимы.

*Нормальные вычисления* #sym.dash.em стратегия вычисления, при которой сначала вызываются все функции до тех пор, пока выражение не будет упрощено до элементарных операций, потом вычисляется полученное упрощенное выражение (подстановка аргументов в функции, пока не дойдем до элементарных операций).
Проблема таких вычислений #sym.dash.em возможны повторные вычисления. 

Пусть на некотором языке заданы функции:
```sml
fun sq x = x * x
fun f (x, y) = sq x + sq y
```

Если бы язык имел аппликативную модель вычислений, то вызов ``` f (1 + 2, 2)``` разрешился бы как:
```
f (1 + 2, 2)
f (3, 2)
sq 3 + sq 2
(op +) (sq 3) (sq 2)
(op +) (3 * 3) (sq 2)
(op +) 9 (sq 2)
(op +) 9 (2 * 2)
(op +) 9 4
13 
```

А если бы нормальную модель, то так #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14589#p28694"):
```
f (1 + 2, 2)
(op +) (sq (1 + 2)) (sq 2)
(op +) ((1 + 2) * (1 + 2)) (sq 2)
(op +) ((1 + 2) * (1 + 2)) (2 * 2)
(op +) (3 * (1 + 2)) (2 * 2)
(op +) (3 * 3) (2 * 2)
(op +) 9 (2 * 2)
(op +) 9 4
13
```

= Объекты первого класса
#caption[
  Понятие "Объект первого класса". Примеры сущностей, являющихся и не являющихся объектами первого класса.
]

*Объект первого класса* #sym.dash.em сущность языка программирования, которую можно:
+ Передавать в качестве аргумента.
+ Возвращать в качестве результата.
+ Связывать с именем.
+ Сохранять как элемент сложной структуры данных.
+ Проверять на равенство.

Сущность может принадлежать, либо не принадлежать объектам первого класса #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14590#p28623").

Например, в SML объектами 1-го класса будут:
- функции; ```sml
fun add (x, y) = x + y
val myFunction = add
```
- значения (включая сложные структуры данных); ```sml
val x = 42
val myList = [1, 2, 3]
```
- записи; ```sml
type person = { name: string, age: int }
val john = { name = "John", age = 30 }
```
- типы данных. ```sml
datatype 'a tree = Empty | Node of 'a * 'a tree * 'a tree
val myTree = Node(1, Node (2, Empty, Empty), Node (3, Empty, Empty))
(* использование Empty как аргумента конструктора Node *)
```

В Ruby, например, следующие сущности будут принадлежать 1-му классу:
- объекты; ```rb
x = 42
def add(x, y)
  x + y
end

my_function = method(:add)
```
- `Proc` и `Proc`-лямбды ```rb
x = -> (x) { x + 5 }
```
- идентификаторы; ```rb
my_symbol = :example
```
- массивы и хэши; ```rb
my_array = [1, 2, 3]
my_hash = { key: 'value' }
```
- классы и модули. ```rb
class MyClass
  # ...
end

my_class = MyClass.new
```
На самом деле в Ruby всё, что является объектом #sym.dash.em объект 1-го класса. А к объектам относится всё вышеперечисленное.

К объектам в Ruby не относятся блоки: им нельзя присвоить имя или сохранить в переменную без перевода в объект класса `Proc`. С ними нельзя делать ничего, кроме как передать в функцию.

= Функции как объекты первого класса
#caption[
  Функции как объекты первого класса на примере языка Standard ML.
]

SML #sym.dash.em функциональный язык программирования, поэтому функция в нём является объектом первого класса. Приведём примеры такого поведения функции.
#list(tight: false)[
  Возврат функции в качестве результата в зависимости от значения аргумента #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14591#p28629"):
  ```sml
  fun realFun a = if a > 0 then Math.cos else Math.sin
  ```
][
  Передача `f` в качестве аргумента в функцию `apply` и возврат результата применения этой функции к значению:
  ```sml
  fun apply f = f 3.0
  ```
][
  Переменным можно присваивать функции:
  ```sml
  fun f x = 5 + x
  val g = f
  val z = g 4
  val k = f 4
  ```
][
  Сохранение в список:
  ```sml
  val l = [ Math.sin, Math.cos ]
  ```
][
  Проверка на равенство:
  ```sml
  val f = Math.sin
  val g = Math.cos
  f = g
  ```
]

= Затенение
#caption[
  Что такое затенение? В чем заключается его механизм?
]

*Затенение* #sym.dash.em объявление идентификатора, который уже существует в окружении. Таким образом, доступ к прежнему значению идентификатора невозможен, поскольку невозможно разрешить неоднозначность между "старым" (возможно, несколькими старыми) и "новым" значениями данного идентификатора #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14592#p28627").

Пример:
```sml
val x = 5
val y = 4
val x = 12 (* (x, 5) затенено в данном окружении *)
```

В функциях SML будет использоваться то значение, которое было
первым в динамическом окружении при объявлении функции:
```sml
val x = 5
val x = "text"
fun f s = x ^ s
f "more"
```

= Лексика, синтаксис, семантика
#caption[
  Лексика, синтаксис, семантика. Что есть что. В частности, в отношении языка программирования.
]

*Лексика* #sym.dash.em словарный состав языка, совокупность слов ("лексем") конкретного языка. Включает в себя:
- *ключевые слова* #sym.dash.em предварительно определенные идентификаторы, имеющие особое синтаксическое значение (`for`, `while`, `if`, `else`, ...);
- *литералы* #sym.dash.em безымянные константы, являющиеся фиксированными значениями (`23`, `-8`, `"abc"`, `7e-8`, ...);
- *идентификаторы* #sym.dash.em имена, задаваемые в программе для переменных, типов и функций (`a2`, `abc`, `zlp`, ...);
- *разделители* #sym.dash.em используются для отделения друг от друга (разделения) лексем языка (#sym.dot.c (пробел), #sym.arrow.r.curve (переход на новую строку), ...);
- *ограничители* #sym.dash.em лексемы, использующиеся для группировки выражений. Например, ограничителями являются `{` `}` в C++ или `(` `)` в Lisp.

*Синтаксис* #sym.dash.em правила построения языковых конструкций. Он описывает форму, последовательность символов, которая составляет синтаксически правильную программу.

*Семантика* указывает, имеет ли смысл в контексте данного языка программирования синтаксически верная конструкция.
Семантика бывает, в частности:
- литерала: задаёт какое-то значение;
- идентификатора: обращается к динамическому окружению; если найдена связь идентификатора с некоторым значением из динамического окружения, значит под этим идентификатором скрывается значение, которое нашли; иначе #sym.dash.em семантическая ошибка;
- выражения: рассмотрим `v1 + v2`; проверяем, для каких типов определен оператор `+`. Если не нашлось оператора, принимающего объекты данных типов #sym.dash.em семантическая ошибка. Иначе подставляем результат операции вместо `v1 + v2` #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14593#p28634").

= Контейнеры
#caption[
  Что понимается под термином "Контейнер"? Какие стандартные контейнеры вы знаете? Какие средства для описания новых контейнеров существуют?
]

*Контейнер* — структура, заключающая в себе другие элементы, относящиеся к тому же или к другому типу.

== Частые контейнеры в SML
=== `option`
```sml
datatype 'a option = NONE | SOME of 'a
```

`NONE` является конструктором, олицетворяющим пустое значение (_ничего_), `SOME` #sym.dash.em конструктор, инкапсулирующий в точности
одно значение (_один элемент_).

```sml
val a = NONE
val b = SOME 5
(isSome a, isSome b)
(* val it = (false, true) : bool * bool *)
valOf b
(* val it = 5 : int *)
valOf a
(* uncaught exception Option *)
```

- `isSome` #sym.dash.em функция, возвращающая `true`, если аргумент является `SOME`;
- `valOf` извлекает значение из `option`. Если аргумент является `NONE`, то поднимается исключение `Option`.

=== Кортеж
Кортеж хранит в себе декартово произведение каких-то значений.
Это контейнер, хранящий ровно $n$ элементов любых типов.
```sml
val p = (5, 2.5)
#1 p
(* val it = 5 : int *)
#2 p
(* val it = 2.5 : real *)
```

=== Список
```sml
datatype 'a list = nil | :: of 'a * 'a list
```
Список #sym.dash.em контейнер, который может в любой момент времени хранить $>= 0$ элементов. В частности, в SML все элементы списка должны быть одного типа.
```sml
val l1 = [1, 2, 3]
val l2 = l1 @ [3, 4]
hd l1
(* val it = 1 : int *)
tl l1
(* val it = [2,3] : int list *)
```

=== Запись
Запись #sym.dash.em набор в точности из $n$ полей, у каждого из которых есть имя и тип #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14594#p28695").
```sml
val z = {name = "Anna", age = 25};
(* val z = {age=25,name="Anna"} : {age:int, name:string} *)
#name z
(* "Anna" : string *)
```

= Классы в Haskell
#caption[
  Классы в Haskell. Что означает термин? Что может относиться к классу и что гарантирует факт такой принадлежности?
]

*Класс в Haskell* обозначает, что при отношении типа `A` к классу `Cl`, для типа `A` разрешены операции, описанные в классе `Cl`. К классу могут относиться любые типы, в том числе и созданные пользователем. Более точно классы в Haskell называются *классами типов данных* (они же ваши `trait` в Rust, только с неявным преобразованием типов).

Классы типов с иерархией наследования напоминают интерфейсы в классических императивных языках программирования. Синтаксис объявления класса:
```
class <Имя класса> <типовая переменная> where
  <op1> :: <сигнатура1>
  <op2> :: <сигнатура2>
  ...
```

Эта концепция позволяет создавать математические абстракции: класс эквивалентности, порядка, предпорядка. У переменных класса существуют, так называемые, *требования* или *ограничения*:
```
instance (SomeType (a), ...) => Class (Type (a, b, c, ...)) where
  op1() = ... -- определение операций, объявленных в классе, для данного типа
  op2() = ...
  op3() = ...
  ...
```
Здесь для того, чтобы `Type (a, b, c, ...)` можно было отнести к классу `Class` нужно, чтобы `a` относился к классу `SomeType`.
Это составляет необходимый функционал для обращения с полиморфными сущностями. 

*Фактом принадлежности типа к классу* является удовлетворение всем операциям класса, т.е. для того, чтобы тип `A` стал относится к классу `Cl`, для типа `A` необходимо определить все операции, описанные в классе `Cl` #cred("https://course.sgu.ru/mod/forum/discuss.php?d=14595#p28715").
